<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>philo: philo ‚Äì Dining Philosophers Simulation in C</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">philo
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">philo ‚Äì Dining Philosophers Simulation in C </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> <img src="https://img.shields.io/badge/license-MIT-green.svg" alt="License: MIT" style="pointer-events: none;" class="inline"/> <img src="https://img.shields.io/badge/language-C-blue.svg" alt="Language: C" style="pointer-events: none;" class="inline"/> <img src="https://img.shields.io/badge/made%20at-42%20Hive-blueviolet" alt="Made at 42/Hive" class="inline"/> <a href="https://github.com/nicolas-lovis/philo"><img src="https://img.shields.io/badge/GitHub-philo-black?logo=github" alt="GitHub Repo" class="inline"/></a></p>
<blockquote class="doxtable">
<p>&zwj;A multithreaded simulation of the classic Dining Philosophers problem. </p>
</blockquote>
<p><a href="https://github.com/to0nsa/philo">üîó View on GitHub</a> <b><a href="https://to0nsa.github.io/philo/">üìö View full documentation</a></b></p>
<p>This project implements a concurrent, real-time simulation of the Dining Philosophers problem using POSIX threads (pthreads) in C. Developed as part of the 42/Hive curriculum, the goal was to explore and solve common issues in <b>parallel programming</b> such as <b>deadlocks</b>, <b>race conditions</b>, and <b>thread synchronization</b>.</p>
<p>Philosophers alternate between thinking, eating, and sleeping, while competing for limited resources (forks). The program ensures each philosopher follows the rules safely and fairly, with careful handling of mutexes, timing, and shared state.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md2"></a>
‚ú® Philo Features</h1>
<details >
<summary >
<b>See features</b></summary>
<p></p>
<p>üîí <b>Thread-Safe Synchronization</b> All shared resources (forks, output, state) are protected with pthread_mutex_t. The simulation ensures no data race or double-access can occur ‚Äî every action is guarded for correctness and consistency.</p>
<p>‚è±Ô∏è <b>Accurate Timing Logic</b> Precise delays are implemented using gettimeofday() and short polling loops to control when philosophers eat, sleep, and think ‚Äî even under tight timing constraints. The system simulates real-time behavior down to the millisecond.</p>
<p>üö® <b>Deadlock &amp; Starvation Prevention</b> The implementation avoids deadlock by alternating fork acquisition order and managing philosopher timings, especially in edge cases like an odd number of philosophers. No philosopher is allowed to starve or monopolize forks.</p>
<p>üí• <b>Graceful Termination</b> The system monitors each philosopher and terminates the simulation cleanly when a philosopher dies or all have completed their required meals. Mutexes are destroyed, memory is freed, and threads are joined safely.</p>
<p>üß© <b>Modular and Readable Codebase</b> Each component (init, validation, routines, monitor, utils) is clearly separated and follows consistent naming conventions. Functions are thoroughly documented with Doxygen and grouped for easy navigation.</p>
<p>üéì <b>Educational Focus</b> This project deepens understanding of pthread basics, critical section design, timing precision, and memory-safe multithreading.</p>
<p></p>
</details>
<hr  />
<h1><a class="anchor" id="autotoc_md4"></a>
‚öôÔ∏è How It Works</h1>
<details >
<summary >
<b>See how it works</b></summary>
<p></p>
<p>The Dining Philosophers problem simulates a group of philosophers sitting around a table with forks placed between them. Each philosopher needs two forks to eat, one on their left and one on their right. The challenge is to design a system where philosophers can eat, sleep, and think without causing deadlocks or starvation.</p>
<p>Here‚Äôs how the simulation works internally:</p>
<p><b>1. Initialization: Setting the Table</b> Before the simulation starts:</p>
<ul>
<li>The program reads the command-line arguments to get the number of philosophers and timing constraints (time to die, eat, sleep, and optionally, how many times each must eat).</li>
<li>It creates a t_philo structure for each philosopher, and sets up pthread_mutex_t for every fork.</li>
<li>Each philosopher knows:<ul>
<li>Their ID</li>
<li>Their left and right fork indices</li>
<li>Their meal count and last meal time</li>
</ul>
</li>
</ul>
<p>The table is now "set" ‚Äî and every philosopher has their seat and utensils.</p>
<p><b>2. Launching Threads: One Per Philosopher</b> Each philosopher is launched in its own thread using pthread_create. Their routine loops through:</p>
<ul>
<li>Thinking ‚Äì where they prepare to eat</li>
<li>Eating ‚Äì where they try to acquire both forks</li>
<li>Sleeping ‚Äì where they rest before starting the loop again</li>
</ul>
<p>To avoid collisions on shared data (forks, output), mutexes are used to ensure synchronization.</p>
<p><b>3. Taking Forks: Safe Locking Strategy</b> To avoid deadlocks, philosophers follow a fork-picking strategy:</p>
<ul>
<li>Even-indexed philosophers pick up the left fork first, then the right.</li>
<li>Odd-indexed ones do the opposite.</li>
</ul>
<p>This asymmetry helps prevent a circular wait, which would freeze all threads.</p>
<p><b>4. Monitoring Death: Life Clock</b> A monitor thread (or a loop in main thread) constantly checks:</p>
<ul>
<li>If any philosopher hasn‚Äôt eaten within time_to_die</li>
<li>If all philosophers have eaten must_eat_count times</li>
</ul>
<p>If a philosopher starves, the simulation ends, printing the time and ID of the dead philosopher. If everyone is full, it also ends cleanly.</p>
<p><b>5. Printing Actions: Thread-Safe Logging</b> Every action (take fork, is eating, is sleeping, etc.) is logged with:</p>
<ul>
<li>Timestamp (in ms since simulation started)</li>
<li>Philosopher ID</li>
<li>Action text</li>
</ul>
<p>A mutex (print_padlock) ensures logs don‚Äôt overlap when multiple threads print simultaneously.</p>
<p><b>6. Exiting Cleanly</b> When the simulation ends:</p>
<ul>
<li>All threads are joined</li>
<li>All mutexes are destroyed</li>
<li>All memory is freed</li>
</ul>
<p>No leaks, no deadlocks, no philosophers left hanging.</p>
<p>üí° <b>Why This Works Efficiently</b> The simulation enforces mutual exclusion using well-placed mutexes and a minimal design:</p>
<ul>
<li>One thread per philosopher (scalable up to 200)</li>
<li>Precise timing and fair rotation</li>
<li>Deadlock avoidance using fork acquisition order</li>
</ul>
<p>This makes the program not only robust, but predictable, deadlock-free, and easy to reason about under concurrent stress.</p>
<p></p>
</details>
<hr  />
<h1><a class="anchor" id="autotoc_md6"></a>
üöÄ Usage</h1>
<details >
<summary >
<b> See usage guide </b></summary>
<p></p>
<p>üõ†Ô∏è <b>To build the Philosopher simulation, simply run:</b></p>
<div class="fragment"><div class="line">make</div>
</div><!-- fragment --><p>üìÑ <b>Arguments</b></p>
<div class="fragment"><div class="line"> text</div>
<div class="line">./philo number_of_philosophers time_to_die time_to_eat time_to_sleep [meals_required]</div>
</div><!-- fragment --><ul>
<li>All values must be positive integers</li>
<li>meals_required is optional</li>
</ul>
<p>üß™ <b>Example run</b></p>
<div class="fragment"><div class="line"> bash</div>
<div class="line">./philo 5 800 200 200</div>
</div><!-- fragment --><p>This starts the simulation with:</p>
<ul>
<li>5 philosophers</li>
<li>800ms time to die</li>
<li>200ms time to eat</li>
<li>200ms time to sleep</li>
</ul>
<p>Each philosopher will cycle through thinking ‚Üí eating ‚Üí sleeping until one dies or the end of time.</p>
<p>üß™ <b>With optional meal limit</b></p>
<div class="fragment"><div class="line">./philo 5 800 200 200 7</div>
</div><!-- fragment --><p>This ends the simulation once each philosopher has eaten 7 times.</p>
<p>üñ•Ô∏è <b>Expected Output</b></p>
<div class="fragment"><div class="line"> csharp</div>
<div class="line">0 1 is thinking</div>
<div class="line">1 2 has taken a fork</div>
<div class="line">2 2 has taken a fork</div>
<div class="line">3 2 is eating</div>
<div class="line">...</div>
</div><!-- fragment --><p>Each log line shows:</p>
<div class="fragment"><div class="line">[timestamp_ms] [philosopher_id] [action]</div>
</div><!-- fragment --><p>All logs are synchronized and printed in order without overlap.</p>
<p></p>
</details>
<hr  />
 <h1><a class="anchor" id="autotoc_md8"></a>
üìù License</h1>
<p>This project is licensed under the [MIT License](LICENSE).</p>
<p>You are free to use, modify, and distribute this code for academic, personal, or professional purposes. Attribution is appreciated but not required.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md10"></a>
üì¨ Contact</h1>
<p>If you have any questions, suggestions, or feedback, feel free to reach out:</p>
<ul>
<li><b>üìß Email:</b> <a href="#" onclick="location.href='mai'+'lto:'+'nic'+'ol'+'as.'+'lo'+'vis'+'@h'+'otm'+'ai'+'l.f'+'r'; return false;">nicol<span class="obfuscator">.nosp@m.</span>as.l<span class="obfuscator">.nosp@m.</span>ovis@<span class="obfuscator">.nosp@m.</span>hotm<span class="obfuscator">.nosp@m.</span>ail.f<span class="obfuscator">.nosp@m.</span>r</a></li>
<li><b>üíª GitHub:</b> <a href="https://github.com/to0nsa">github.com/to0nsa</a></li>
</ul>
<p>You're also welcome to open an issue or leave a comment on the repository. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
